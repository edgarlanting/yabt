#!/usr/bin/env python3



# pylint: disable=line-too-long



import yabt
import sys
import os
import argparse
import gzip
import shutil
import json
import re
import signal



def trap_sigint(signal, frame):
	sys.exit(0)



def decompress_gzip_files(start_dir):
	"""Walk a directory tree and decompress all gzip files found.
	"""
	print("Expanding bundle files")

	for root, dirs, files in os.walk(start_dir):
		for each_file in files:
			if not each_file.endswith(".gz"):
				continue

			file_with_path = root + os.sep + each_file

			file_with_path_no_ext = file_with_path[:-3]

			try:
				with gzip.open(file_with_path, "rb") as f_in:
					with open(file_with_path_no_ext, "wb") as f_out:
						shutil.copyfileobj(f_in, f_out)

			except EOFError:
				print("Failed to expand", file_with_path, "EOF reached, incomplete file?")

			except OSError:
				print("Failed to expand", file_with_path + ", not a gzip file?")

			else:
				os.remove(file_with_path)



def format_json(bundle_dir):
	"""Format the JSON files into a human-readable form.
	"""
	print("Formatting JSON files")

	for root, dirs, files in os.walk(bundle_dir):
		for each_file in files:
			if not each_file.endswith(".json"):
				continue

			file_with_path = root + os.sep + each_file

			with open(file_with_path, "r+") as json_file_handle:
				try:
					json_data = json.load(json_file_handle)

					json_file_handle.seek(0)

					json_file_handle.write(json.dumps(json_data, indent=2, sort_keys=True))
					json_file_handle.write("\n")

				except json.decoder.JSONDecodeError:
					print("Failed to parse JSON:", file_with_path, file=sys.stderr)



if __name__ == "__main__":
	# What options were we called with?
	parser = argparse.ArgumentParser(description="Yet Another Bundle Tool: A tool used to analyze DC/OS diagnostic bundles")

	parser.add_argument("-d", "--debug", dest="debug_mode",
							default=False, action="store_true",
							help="Enable debug mode")

	parser.add_argument("bundle_name", metavar="bundle_name",
							type=str, nargs="+",
							help="The bundle file or directory")

	# TODO: Add option to only look at a specific node
	# TODO: Add option to do checks and only extract unless given this or another option
	# TODO: Add option to list what checks will be done
	# TODO: Add option to do "deep inspect" checks (e.g. show when ooms happened and what processes were killed)
	# TODO: Add option to list what "deep inspect" checks are available

	yabt_args = parser.parse_args()


	# Trap CTRL+C (SIGINT)
	signal.signal(signal.SIGINT, trap_sigint)


	# Verify we have a bundle arg
	if not len(yabt_args.bundle_name) == 1:
		print("Invalid number of bundle names passed, shell quoting problem?", file=sys.stderr)

		sys.exit(1)

	else:
		bundle_name = yabt_args.bundle_name[0]


	# TODO: Support service diagnostic bundles


	# Does the named bundle exist?
	if not os.path.exists(bundle_name):
		print("No such bundle found:", bundle_name, file=sys.stderr)

		sys.exit(1)


	# Decompress the bundle and the files within it
	if bundle_name.endswith(".zip") or os.path.exists(bundle_name + os.sep + "summaryReport.txt"):
		bundle_type = "diag_bundle"

		bundle_dir = yabt.dcos.extract_bundle(bundle_name)

		decompress_gzip_files(bundle_dir)

		format_json(bundle_dir)

	elif bundle_name.endswith(".tgz"):
		bundle_type = "oneliner_bundle"

		bundle_dir = yabt.dcos.extract_oneliner(bundle_name)

	elif os.path.isdir(bundle_name):
		bundle_dir = bundle_name
		bundle_type = "diag_bundle"

	else:
		print("Unable to determine bundle type", file=sys.stderr)

	# FIXME: Support already-extracted oneliner bundle


	# Create the node objects list
	node_objs = yabt.dcos.get_nodes(bundle_dir, bundle_type)

	yabt.dcos.print_nodes(node_objs)


	# Health checks
	if bundle_type == "diag_bundle":
		yabt.check.dcos_version(node_objs)
		yabt.check.firewall_running(node_objs)
		yabt.check.state_size(node_objs)

	yabt.check.missing_agents(node_objs)
	yabt.check.time_sync(node_objs)
	yabt.check.kmem_presence(node_objs)
	yabt.check.zk_fsync(node_objs)
	yabt.check.zk_diskspace(node_objs)
	yabt.check.zk_connection_exception(node_objs)
	yabt.check.oom_presence(node_objs)
	yabt.check.crdb_ranges(node_objs)

	# TODO: check_mesos_master()
	# TODO: List each Mesos leader change
	# TODO: List each ZK leader change
	# TODO: List each Marathon leader change
	# TODO: Check for inactive frameworks
	# TODO: Check for unreachable tasks
	# TODO: Check for nodes missing the Docker daemon running
	# TODO: Check for CRDB time sync events
	# TODO: Check for private registry certificate errors
	# TODO: Check for overlay master module in RECOVERING state events

