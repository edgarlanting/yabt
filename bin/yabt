#!/usr/bin/env python3



# pylint: disable=line-too-long



import yabt
import sys
import os
import argparse
import gzip
import shutil
import json
import re
import signal
import glob
import zipfile
import tarfile



def trap_sigint(signal, frame):
	sys.exit(0)



if __name__ == "__main__":
	# What options were we called with?
	parser = argparse.ArgumentParser(description="Yet Another Bundle Tool: A tool used to analyze DC/OS diagnostic bundles")

	parser.add_argument("-d", "--debug", dest="debug_mode",
							default=False, action="store_true",
							help="Enable debug mode")

	parser.add_argument("bundle_name", metavar="bundle_name",
							type=str, nargs="+",
							help="The bundle file or directory")

	# TODO: Add option to only look at a specific node
	# TODO: Add option to skip checks and only extract unless given this or another option

	yabt_args = parser.parse_args()


	# Trap CTRL+C (SIGINT)
	signal.signal(signal.SIGINT, trap_sigint)


	# Verify we have a bundle arg
	if not len(yabt_args.bundle_name) == 1:
		print("Invalid number of bundle names passed, shell quoting problem?", file=sys.stderr)

		sys.exit(1)

	else:
		bundle_name = yabt_args.bundle_name[0]


	# Does the named bundle exist?
	if not os.path.exists(bundle_name):
		print("No such bundle found:", bundle_name, file=sys.stderr)

		sys.exit(1)


	# Decompress the bundle and the files within it
	bundle_type = yabt.util.get_bundle_type(bundle_name)
	bundle_dir = yabt.util.get_bundle_dir(bundle_name)

	if os.path.isdir(bundle_name):
		pass

	elif yabt.util.is_bundle_extracted(bundle_name):
		print("Bundle has already been extracted, using existing directory,", bundle_dir)

	elif bundle_type == "dcos_diag":
		bundle_dir = yabt.dcos.bundle.extract_diag(bundle_name)
		yabt.util.decompress_gzip_files(bundle_dir)
		yabt.util.format_json(bundle_dir)

	elif bundle_type == "dcos_oneliner":
		bundle_dir = yabt.dcos.bundle.extract_oneliner(bundle_name)

	elif bundle_type == "service_diag":
		bundle_dir = yabt.service.bundle.extract(bundle_name)

	elif bundle_type == "konvoy_diag":
		bundle_dir = yabt.konvoy.bundle.extract(bundle_name)


	# Create the node objects list
	if bundle_type == "dcos_diag" or bundle_type == "dcos_oneliner":
		node_objs = yabt.dcos.bundle.get_nodes(bundle_dir, bundle_type)
		yabt.dcos.bundle.print_nodes(node_objs)

	elif bundle_type == "konvoy_diag":
		node_objs = yabt.konvoy.bundle.get_nodes(bundle_dir)
		yabt.konvoy.bundle.print_nodes(node_objs)


	# Health checks
	if bundle_type == "dcos_diag":
		yabt.dcos.check.dcos_version(node_objs)
		yabt.dcos.check.firewall_running(node_objs)
		yabt.dcos.check.state_size(node_objs)
		yabt.dcos.check.inactive_frameworks(node_objs)
		yabt.dcos.check.missing_dockerd(node_objs)
		yabt.dcos.check.unreachable_agents_mesos_state(node_objs)

	if bundle_type == "dcos_diag" or bundle_type == "dcos_oneliner":
		yabt.dcos.check.unreachable_agents_mesos_log(node_objs)
		yabt.dcos.check.mesos_leader_changes(node_objs)
		yabt.dcos.check.zk_leader_changes(node_objs)
		yabt.dcos.check.marathon_leader_changes(node_objs)
		yabt.dcos.check.check_time_failures(node_objs)
		yabt.dcos.check.kmem_presence(node_objs)
		yabt.dcos.check.zk_fsync(node_objs)
		yabt.dcos.check.zk_diskspace(node_objs)
		yabt.dcos.check.zk_connection_exception(node_objs)
		yabt.dcos.check.oom_presence(node_objs)
		yabt.dcos.check.crdb_underrep_ranges(node_objs)
		yabt.dcos.check.crdb_monotonicity_error(node_objs)
		yabt.dcos.check.crdb_contact_error(node_objs)
		# TODO: Check for private registry certificate errors
		# TODO: Check for overlay master module in RECOVERING state events

	if bundle_type == "service_diag":
		pass

	if bundle_type == "konvoy_diag":
		pass

